{"./":{"url":"./","title":"Introduction","keywords":"","body":"LeetCode For TypeScript LeetCode problems' submissions & top randed with TypeScript. Submissions was completed by myself. Top Randed includes the best submissions complated by other guys in LeetCode.com with JavaScript. Author: Yalda Github: leetcode-ts Blog: www.yalda.cn Online Book: www.yalda.cn/leetcode-ts Topics Array¹², Dynamic Programming⁴, Math³, String¹, Tree¹, Algorithms # Title Topics Difficulty 0001 two-sum String Easy 0003 longest-substring-without-repeating-characters String Easy 0004 median-of-two-sorted-arrays String Hard 0014 longest-common-prefix String Easy 0017 letter-combinations-of-a-phone-number String Easy 0050 powx-n String Easy 0074 search-a-2d-matrix String Easy 0136 single-number String Medium 0169 majority-element String Easy 0202 happy-number String Easy 0240 search-a-2d-matrix-ii String Easy 0344 reverse-string String Easy 0724 find-pivot-inde String Hard "},"TOPICS.html":{"url":"TOPICS.html","title":"Topics","keywords":"","body":"Related Topics Array 0014.Longest Common Prefix 0017.Letter Combinations of a Phone Number String 0001.Two Sum 0003.Longest Substring Without Repeating Characters 0074.Search a 2D Matrix "},"algorithms/0001.two-sum/":{"url":"algorithms/0001.two-sum/","title":"0001.two-sum","keywords":"","body":"1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Related Topics Array Hash Table Submissions I: 嵌套循环遍历 这事最偷懒的办法，快速实现后，再考虑优化方案 使用Array.forEach在性能上会有点损耗(测试用例:61ms到59ms) Time: 2018.9.13 Status: Accepted Runtime: 120ms | 40.065% var twoSum = (nums: number[], target: number): number[] => { for (let i: number = 0; i II: 哈希存储 Status: Accepted Runtime: 80 ms | 59.00% var twoSum = (nums: number[], target: number): number[] => { const map: any = {}; nums.forEach((i, k) => (map[i] = k)); for (let i = 0; i III: 方案二：哈希存储 Status: Accepted Runtime: 56ms | 100.00% var twoSum = (nums: number[], target: number): number[] => { const map: any = {}; const length: number = nums.length; for (let i = 0; i IV: 哈希遍历 Status: Accepted Runtime: 52ms | 100% var twoSum = (nums: number[], target: number): number[] => { const map: any = {}; const length = nums.length; for (let i = 0; i Top Ranked "},"algorithms/0003.longest-substring-without-repeating-characters/":{"url":"algorithms/0003.longest-substring-without-repeating-characters/","title":"0003.longest-substring-without-repeating-characters","keywords":"","body":"3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Related Topics Hash Table Two Pointers String Sliding Window Submissions I: ** Time: 2018.10.19 Status: Output Limit Exceeded var lengthOfLongestSubstring = (s: string): number => { let maxSub = \"\", currentSub = \"\"; const arr: string[] = s.split(\"\"); arr.forEach((s: string) => { if (currentSub.includes(s)) { // 存在 if (currentSub.length >= maxSub.length) { maxSub = currentSub; } let [lStr, rStr] = currentSub.split(s); currentSub = rStr || \"\"; currentSub += s; } else { // 不存在 currentSub += s; if (currentSub.length >= maxSub.length) { maxSub = currentSub; } } }); return maxSub.length; }; II: ** Time: 2018.10.19 Status: Accepted Runtime: 116ms | 55.08% var lengthOfLongestSubstring = (s: string): number => { let maxSub: string = \"\", currentSub: string = \"\"; const arr: string[] = s.split(\"\"); arr.forEach((s: string) => { if (currentSub.includes(s)) { // 存在 if (currentSub.length >= maxSub.length) { maxSub = currentSub; } let [lStr, rStr] = currentSub.split(s); currentSub = rStr || \"\"; currentSub += s; } else { // 不存在 currentSub += s; if (currentSub.length >= maxSub.length) { maxSub = currentSub; } } }); return maxSub.length; }; Top Ranked "},"algorithms/0004.median-of-two-sorted-arrays/":{"url":"algorithms/0004.median-of-two-sorted-arrays/","title":"0004.median-of-two-sorted-arrays","keywords":"","body":"4. Median of Tow Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example nums1 = [1, 3] nums2 = [2] The median is 2.0 nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Related Topics Array Binary Search Divide and Conquer Submissions I: 递归 Time: 2019.1.4 Status: Accepted Runtime: 168ms | 19.48% Memory: 15.8MB | var findMedianSortedArrays = (nums1: number[], nums2: number[]): number => { const findKth = (nums1: number[], nums2: number[], k: number): number => { var m: number = nums1.length; var n: number = nums2.length; if (m > n) { return findKth(nums2, nums1, k); } if (m === 0) { return nums2[k - 1]; } if (k === 1) { return Math.min(nums1[0], nums2[0]); } var pa = Math.floor(k / 2) nums2[pb - 1]) { var t2 = nums2.slice(pb); //nums2.splice(0,pb); return findKth(nums1, t2, k - pb); } else { return nums1[pa - 1]; } }; var m = nums1.length; var n = nums2.length; var tol = m + n; if (tol / 2 - Math.floor(tol / 2) > 0.1) { return findKth(nums1, nums2, Math.floor(tol / 2) + 1); } else { return ( (findKth(nums1, nums2, Math.floor(tol / 2)) + findKth(nums1, nums2, Math.floor(tol / 2) + 1)) / 2 ); } }; Top Ranked "},"algorithms/0014.longest-common-prefix/":{"url":"algorithms/0014.longest-common-prefix/","title":"0014.longest-common-prefix","keywords":"","body":"14. Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example Input: [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Input: [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Note All given inputs are in lowercase letters a-z. Related Topics String Submissions I: 循环遍历 刚拿到这题没有细想，认为这题比较简单；直接使用循环遍历的方式一遍一遍顺序访问数组。当子字符串不相等时 Break，结果却超时了。简单了分析了原因在长数组的情况下，过多的进行了顺序访问，实践复杂度为 O(k*n)。便放弃广度优先，改为深读优先。后面发现，是长度为 1 的数组进入了死循环。 Status: Time Limit Exceeded var longestCommonPrefix = (strs: string[]): string => { let prefix: string = \"\"; if (strs && strs.length > 0) { let point = 1; while (true) { prefix = strs[0].slice(0, point); for (let i = 0; i II: 单次遍历 没有兼容好空字符串的问题（PS:条件不是 a-z 么？WTF?） Status: Time Limit Exceeded Input: : [\"\",\"\"] var longestCommonPrefix = (strs: string[]): string => { let prefix: string = \"\"; if (strs.length == 1) { return strs[0]; } else if (strs.length > 1) { let point = 1; while (true) { prefix = strs[0].slice(0, point); for (let i = 0; i III: 单次遍历 使用 strs[0] 作为初始前缀串，逐一遍历 strs[] 元素进行比较，如 String.indexOf !== 0 则自减长度 1，直至成立后继续访问后面的元素。 Time: 2019.03.26 Status: Accepted Runtime: 60ms | 97.88% Memory: 33.8MB | 86.74% var longestCommonPrefix = (strs: string[]): string => { if (strs && strs.length > 0) { let prefix: string = strs[0]; // 使用 strs[0] 作为初始前缀串 for (let i = 1; i Top Ranked "},"algorithms/0017.letter-combinations-of-a-phone-number/":{"url":"algorithms/0017.letter-combinations-of-a-phone-number/","title":"0017.letter-combinations-of-a-phone-number","keywords":"","body":"17. Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note Although the above answer is in lexicographical order, your answer could be in any order you want. Related Topics String Backtracking Thinking 笛卡尔积有很多应用场景： 输入法简拼，快捷打字 电商规格项规格值算 SKU 商品详情页面下单时勾选规格值，根据 SKU 库存排除无货的规格值可选 电商营销场景组合优惠券场景 Submissions I: 笛卡尔积 var letterCombinations = function(digits: string) { // 拨号键盘 const keymap: any = { 2: [\"a\", \"b\", \"c\"], // 2 3: [\"d\", \"e\", \"f\"], // 3 4: [\"g\", \"h\", \"i\"], // 4 5: [\"j\", \"k\", \"l\"], // 5 6: [\"m\", \"n\", \"o\"], // 6 7: [\"p\", \"q\", \"r\", \"s\"], // 7 8: [\"t\", \"u\", \"v\"], // 8 9: [\"w\", \"x\", \"y\", \"z\"] // 9 }; const s = digits.split(\"\").map(d => keymap[d]); let result = []; let stack = []; let point = 0; for (let i = 0, array = s[point++]; i Top Ranked "},"algorithms/0050.powx-n/":{"url":"algorithms/0050.powx-n/","title":"0050.powx-n","keywords":"","body":"50. Pow(x,n) Implement pow(x, n), which calculates x raised to the power n (xn). Example Input: 2.00000, 10 Output: 1024.00000 Input: 2.10000, 3 Output: 9.26100 Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note -100.0 n is a 32-bit signed integer, within the range [−231, 231 − 1] Related Topics Math Binary Search Submissions I: Math.pow 这里偷懒，直接调用了全局对象 Math 静态方法，Math#pow Time: 2019.04.19 10:39 Status: Acceted Runtime: 76 ms > 42.42% Memory: 34.2 MB var myPow = function(x: number, n: number): number | string { return Math.pow(x, n).toFixed(5); }; Top Ranked "},"algorithms/0074.search-a-2d-matrix/":{"url":"algorithms/0074.search-a-2d-matrix/","title":"0074.search-a-2d-matrix","keywords":"","body":"74. Search a 2D Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Related Topics Array Binary Search Submissions I: 双层遍历 Time: 2019.3.15 Status: Accepted Runtime: 64ms | 58.68% Memory: 35.4MB | 7.41% var searchMatrix = (matrix: number[][], target: number): boolean => { for (let i = 0; i Top Ranked "},"algorithms/0136.single-number/":{"url":"algorithms/0136.single-number/","title":"0136.single-number","keywords":"","body":"136. Single Number Given a non-empty array of integers, every element appears twice except for one. Find that single one. Example Input: [2,2,1] Output: 1 Input: [4,1,2,1,2] Output: 4 Note Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Related Topics Hash Table Bit Manipulation Submissions I: 这里已经没有优化空间了，想想其他方法 Time: 2019.04.19 Status: Accepted Runtime: 64 ms | 81.78% Memory: 36.9MB | 41.03% var singleNumber = (nums: number[]): number => { let map: any = {}; let length: number = nums.length; for (let i: number = 0; i Top Ranked "},"algorithms/0169.majority-element/":{"url":"algorithms/0169.majority-element/","title":"0169.majority-element","keywords":"","body":"169. Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example Input: [3,2,3] Output: 3 Input: [2,2,1,1,1,2,2] Output: 2 Related Topics Array Divide and Conquer Bit Manipulation Submissions I: 通用解法 Time: 2019.03.01 Status: Accepted Runtime: 68ms | 87.42% var majorityElement = (nums: number[]): number => { let map: any = {}; nums.forEach(n => { if (n in map) { map[n]++; } else { map[n] = 1; } }); let maximum = 0; let maxKey: any; for (let k in map) { if (map[k] >= maximum) { maximum = map[k]; maxKey = k; } } return maxKey; }; Top Ranked "},"algorithms/0202.happy-number/":{"url":"algorithms/0202.happy-number/","title":"0202.happy-number","keywords":"","body":"202. Happy Number Write an algorithm to determine if a number is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example Input: 19 Output: true Explanation: 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 Related Tips Hash Table Math Submissions I: 一开始以为这题很简单，也没仔细考虑；使用了 Array.reduce() 和 While 控制语句完事；跑测试用例时才发现，第二条用例就没有通过。问题出在时间复杂度上，这里必须对死循环进行处理。 Time: 2019.03.15 Status: Time Limit Exceeded Input: : 2 var isHappy = (n: number): boolean => { let result: number = n; let f = (n: number): any => String(n) .split(\"\") .reduce((x: string, y: string) => String(Math.pow(Number(x), 2) + Math.pow(Number(y), 2)) ); while (result !== 1) { result = f(result); } return true; }; Top Ranked "},"algorithms/0240.search-a-2d-matrix-ii/":{"url":"algorithms/0240.search-a-2d-matrix-ii/","title":"0240.search-a-2d-matrix-ii","keywords":"","body":"240. Search a 2D Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false. Related Tips Binary Search Divide and Conquer Submissions I: 双层遍历 Status: Accepted Runtime: 460ms > 22.93% var searchMatrix = (matrix: number[][], target: number): boolean => { for (let i: number = 0; i Top Ranked "},"algorithms/0344.reverse-string/":{"url":"algorithms/0344.reverse-string/","title":"0344.reverse-string","keywords":"","body":"344. Reverse String Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] Note Your algorithm should run in O(n) time complexity and O(1) space complexity. Example Input: [1,2,3,4,5] Output: true Input: [5,4,3,2,1] Output: false Related Topics Binary Search Dynamic Programming Thinking 模拟 Array.reverse() 的实现；在 不得使用分配额外的空间 空间复杂度是 O(1) 的 in-place algorithms Submissions I: Array.prototype.reverse 由于 Array 对象内置了 reverse 函数，先采用这个方法看看效率。然后自行实现 reverse Status: Accepted var reverseString = (s: string[]): void => { s.reverse(); }; II: O(1) extra memory 迫使无法使用额外的数组进行缓存； Time: 2019.03 Status: Wrong Answer Input: : Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"h\",\"e\",\"l\",\"l\",\"o\"] Expected: [\"o\",\"l\",\"l\",\"e\",\"h\"] var reverseString = (s: string[]): void => { let arr: string[] = []; for (let i = s.length; i > 0; i--) { arr.push(s[i - 1]); } s = arr; }; Top Ranked "},"algorithms/0724.find-pivot-index/":{"url":"algorithms/0724.find-pivot-index/","title":"0724.find-pivot-index","keywords":"","body":"724. Find Pivot Index Given an array of integers nums, write a method that returns the \"pivot\" index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example Input: nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs. Input: nums = [1, 2, 3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Note The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. Related Tips Array Submissions I: ** var pivotIndex = (nums: number[]): number => { // nums.length >= 3,否则返回0 // initial let lPointer = 1; // 左标 let lSum = nums[0]; // 左和 let rPointer = 2; // 右标 let rSum = nums[2]; // 右和 // step1：左和右和 // step3-0：右标达到数组长度；return -1 // step3-1：右标未达到数组长度,右标继续遍历 return nums.length; }; II: ** export function pivotIndex2(nums: number[]): number { const _len = nums.length; let lSum = 0; // 左和 let rSum = 0; // 右和 nums.map(n => (rSum += n)); if (_len === 0) { return -1; } else { for (let i = 0; i Top Ranked "}}